# 목차
1. [[JPG와 PNG의 차이]]
2. [[동적 프로그래밍(Dynamic Programing)]]

# 1. JPG와 PNG의 차이?

 - JPG: 손실 압축으로 원본이 훼손(JPEG 알고리즘)
 - PNG: 비손실 압축 방식으로 원본이 훼손되지 않음.

### JPEG 알고리즘
- DCT(이산 코사인 변환, Discrete Cosine Transform)을 적용
- 이후 데이터를 줄이기 위해 Quantization(양자화) 진행.
- Quantization(양자화): 자연스러운 색상을 단순화 진행. -> 색수 감소 -> 데이터 손실 발생

<img src="image\20240225154526.png">
- 좌: JPG / 우: PNG

---
### JPG의 특징

#### 장점
1. 모든 주요 장치 및 플랫폼에서 가장 널리 지원되는 파일 형식
2. 우수한 압축결과 제공
3. EXIF 정보에 대한 통합 지원 제공

#### 단점
1. 손실 압축으로 인한 이미지 품질의 저하
2. PNG와 같은 투명도 지원 X

---
### PNG의 특징

#### 장점
1. 이미지 배경의 투명도를 지원하여 편집 및 표시에 이상적
2. PNG는 이미지의 원래 품질을 유지하며 무손실 압축 따름.
3. 이미지의 메타데이터에 대한 세부 정보를 쉽게 추가하거나 다른 레이어에서 작업할 수 있음.

#### 단점
1. PNG는 기본 EXIF 세부정보 지원 X
2. 무손실 압축 기술로 인해 파일크기 꽤 큼.

---

# 2. 동적 프로그래밍(Dynamic programming)

: **특정 범위까지의 답을 구하기 위해 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법.**
- **하나의 큰 문제를 여러 작은 문제로 나눠 그 결과를 저장 후 다시 큰 문제를 해결하는 방법임**
- 큰 문제 -> 작은 문제로 쪼갬 -> 답 기억 후 재활용 => '기억하며 풀기'로도 불림.

## DP를 쓰는 이유

1. 일반적 재귀(Naive Recursion)와의 차이점
	- 일반적 재귀를 단순 사용 시 작은 문제들이 반복되어 비효율적 계산이 될 수 있음.

	- 예시: 피보나치 수열 문제
		- 단순 재귀로 풀 경우: return f(n) = f(n-1) + f(n-2)
		- 이 연산을 하며 하나씩 나아갈 경우, 100 번째 피보나치 수를 구하기 위해 호출되는 함수 수는 기하 급수적으로 증가한다.
		- f(n-1)에서 구한 f(n-2)를 다시 한번 더 구하는 과정을 거쳐야 하기 때문.
	- 이런 문제를 막기 위해서 미리 구해놓은 결과 값을 재사용할 수 있도록 코드를 활용한다면, 200회 내에 100번쨰 피보나치 수를 구할 수 있다.

최종적으로 DP를 이용하여 문제를 푼다면, 매우 효율적인 문제 해결이 가능해진다.
O(n^2) -> O(f(n))으로 연산이 개선됨.

## DP의 사용 조건

1. Overlapping Subproblems(겹치는 부분 문제)
2. Optimal Substructure(최적 부분 구조)

### Overlapping Subproblems

- DP는 기본적으로 문제를 나누고, 그 문제의 결과 값을 재활용하여 전체 답 구함.
- 동일한 작은 문제가 반복적으로 나타나면 사용 가능

: DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 해당 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.
- 예시: 피보나치 수열 문제

### Optimal Substructure

- '부분 문제의 최적 결과 값 사용해 전체 문제의 최적 결과를 낼 수 있는 경우' 의미
- 특정 문제의 정답은 문제 크기에 관계 없이 항상 동일하다.
- 예시: 최단 경로 문제

## DP 사용하기

1) DP로 풀 수 있는 문제인지 파악하기
2) 문제의 변수 파악
3) 변수 간 관계식 만들기(점화식)
4) 메모하기(memoization or tabulation)
5) 기저 상태 파악하기
6) 구현하기
	1) Bottom-Up(Tabulation 방식): 반복문 사용
	2) Top-Down(Memoiztion 방식): 재귀 사용

---

# 3. Virtual Memory

### 메모리?

- 프로그램과 프로그램 수행에 필요한 데이터 및 코드를 저장하는 장치
- 내부 기억 장치(주 기억 장치), 외부 기억 장치(보조 기억 장치)로 분류됨.
	- 주 기억 장치
		- DRAM, CPU 내 레지스터(Register)와 캐쉬(Cache memory) 등이 해당.

	- 보조 기억 장치
		- SDD, HDD 등이 해당됨.

### 기상 메모리의 등장 배경

- 초기 컴퓨터에서는 사용 가능한 RAM 용량이 가장 큰 실행 애플리케이션 공간보다 크기가 커야 했음.
- 오버레이 기법을 이용하여 메모리 부족 문제를 해결하고자 했으나 결국 같은 문제 발생.
	- 오버레이 기법: 애플리케이션 일부분만 기억 장치에 올려 실행하도록 지정
- 가상 메모리 기법: 애플리케이션을 실행하는데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 최소한 얼마만큼의 메모리가 필요한가에 집중해 문제 해결.
	- 메모리의 접근은 순차적이고 지역화 되어있기 떄문.
	- 그렇다면 일부분만 메모리에 올려진다면, 나머지는 디스크에 올려야 한다.
	- 가상 메모리의 핵심은 보조 기억장치이다.

### 가상 메모리

#### 요약
- 메모리가 실제보다 많아 보이게 하는 기술.
- 어떤 프로세스가 모든 메모리에 프로세스 전체가 올라가지 않아도 실행이 되지 않는다는 점에 착안하여 고안됨.
- 디스크가 RAM의 보조 기억 장치처럼 작동하는 것.
- **결론적으로 빠르고 작은 기억장치를 크고 느린 기억장치와 병합하여 하나의 빠른 기억장치처럼 동작하게 하는 것임.**

#### MMU

- 가상 메모리를 구현하기 위한 특수 메모리 관리 하드웨어.
- 최근 아키텍처에서는 프로세서와 같은 칩에 회로로 삽입됨.
- MMU의 역할
	- 가상 주소를 물리주소로 변환하고, 메모리 보호하는 기능 수행
	- MMU 사용 시 CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업
	- 최종적으로 페이지와 주소 번역 정보를 기억하는 작업이 가상메모리 구현에 결정적 절차임.

### 요구 페이징(Demand Paging)
: CPU가 요청 시 프로세스의 데이터를 메모리에 올리는 것을 의미.
-> 처음부터 모든 데이터를 메모리로 적재하지 않음.

### 페이지 폴트(Page Fault)

- 어떤 프로그램이 가상 메모리 공간에는 존재하나, 시스템 RAM에 현재 존재하지 않는 데이터, 코드에 접근시 발생하는 현상.
- 운영체제는 그 데이터를 메모리로 가져와 페이지 폴트가 발생하지 않은 것처럼 프로그램이 계속 작동하게 해줌.
- 페이지 폴트가 자주 일어날 수록 운영체제의 성능이 많이 저하되므로 발생하지 않게 하는 것이 중요함.
	- 이를 최소화 하는 방법: 페이지 교체 정책(Page Replacement Policy)
	- 메모리가 꽉 차있을 때, 기존 페이지 중 하나를 물리 메모리에서 저장 메체로 이동
	- 새 페이지를 비워진 메모리 공간에 올림. 기존 페이지 중 어떤 것을 내리면 좋을지에 대한 알고리즘을 짠 것이 바로 교체 알고리즘.

### TLB(Translation Lookaside Buffer): 페이지 정보 캐쉬
: 가상 메모리 주소를 물리적 주소로 변환하는 속도를 높이기 위해 사용.
- 최근 일어난 가상 메모리와 물리 주소의 변환 테이블을 저장해둠.
- CPU가 가상 주소를 가지고 메모리 접근 시 TLB에 접근해 가상 주소에 해당하는 물리주소 찾기.
- TLB가 매핑에 존재하지 않는다면 MMU가 페이지 테이블에 해당되는 물리주소로 변환 후 메모리에 접근하게 됨.

- TLB의 장점
	- **물리 주소를 가지고 있다면 RAM에 2번 들리지 않고, 바로 물리주소 찾을 수 있음.**


---
# 4. Semaphore(세마포어) & Mutex(뮤텍스)

- 프로세스 간 메세지 전송, 공유 메모리를 통해 특정 데이터를 공유 시 문제 발생
- 공유 자원에 여러 프로세스가 동시 접근 시 1개 데이터에 1개 프로세스가 접근 할 수 있도록 해야 함.
- Semaphore는 이를 위해 고안되었음.

## Semaphore

**멀티 프로그래밍 환경에서 공유된 자원에 대한 접근을 제한하는 방법**
: 공유된 자원의 데이터 또는 임계영역(Critical Section) 등에 **여러 Process, Thread가 접근하는 것을 막아줌**(= 동기화 대상이 하나 이상일 경우)
- 상호 배제 되도록 하는 기술

<img src="image\20240225205307.png">

## Mutex

**동시 프로그래밍 시 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘** 
: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 **1개의 Process 또는 Thread가 접근하는 것을 막아줌**(동기화 대상이 하나)

![[Pasted image 20240225204049.png]]
## Critical section
: 다중 프로그래밍 운영체제에서 여러 프로세스가 데이터를 공유하며 수행될 때 **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**을 지칭함.

- 만약 공유 데이터를 여러 프로세스가 동시에 접근하면 시간적 차이로 잘못된 결과를 만들어 낼 수 있다.
- 이를 막기 위해 공유데이터를 액세스를 하고싶다면 다른 프로세스들은 절대 그 데이터를 액세스하지 못하게 해야 한다.

## Mutex & Semaphore의 차이

| Category | Mutex         | Semaphore                             |
| -------- | ------------- | ------------------------------------- |
| 동기화 개수   | 대상이 1일 경우     | 대상이 1 이상인 경우                          |
| 호환 유무    | X             | Mutex = Binary Semaphore(0, 1로 표현 가능) |
| 자원 소유    | 자원 소유 + 책임    | 자원 소유 불가                              |
| 해제 방법    | 소유 Thread만 해제 | 소유하지 않는 Thread도 해제 가능                 |
| 파일의 범위   | 프로세스 범위       | 시스템 범위에 걸쳐 시스템 상 파일로 존재함.             |

---

# 5. Cache란?

: 레지스터, 메인 메모리와 함께 메모리 계층 구조의 전통적 핵심 계층 중 하나

<img src="image\20240226123412.png">

## Cache memory의 작동 원리: 데이터 지역성

: 총 3가지로 구분됨.
- 시간 지역성(Temporal locality)
- 공간 지역성(Spatal locality)
- 순차적 지역성(Sequential locality)

- 적중(Hit): CPU가 주 기억 장치 메모리에 접근하기 전에 캐시메모리에 원하는 데이터가 존재한 경우.
	- 적중률(Hit Ratio) = 캐시 메모리 적중 횟수 / 전체 메모리 참조 횟수 X 100
- 부적중(Miss): CPU가 요청한 데이터가 캐시 메모리에 없어 주 기억장치에서 데이터를 찾은 경우:
	- 부적중률(Miss Ratio) = 1 - 적중률
	- Cold Miss: 해당 메모리 주소를 처음 불러 나는 미스
### 시간 지역성
: for & while 같은 반복문에 사용되는 조건 변수처럼 한번 사용된 데이터는 조건 변수처럼 잠시 후 다시 참조될 가능성이 높음

### 공간 지역성
: `A[0], A[1]` 와 같은 데이터 배열에 연속으로 접근할 경우, 참조된 데이터 근처에 있는 데이터가 사용될 확률이 더 높음.

### 순차적 지역
: 분기가 발생하는 비순차적 실행이 아닌 이상 명령어들이 메모리에 저장된 순서대로 실행하는 특성을 이용한 원리. 순차적일수록 다음 순서의 데이터가 사용될 확률이 있다.

## Cache memory의 특징

- 주 기억장치와 CPU 사이에 위치하며, 자주 사용하는 프로그램과 데이터를 기억.
- 캐시 메모리는 메모리 계층 구조에서 가장 빠른 소자, 처리 속도가 CPU와 비슷.
- 주 기억장치를 접근하는 횟수가 줄어들어 컴퓨터의 처리속도가 향상됨.
- 캐시 주소 표는 검색 기간을 단축시키기 위해 주로 연관 기억장치를 사용.
- 캐시의 크기는 수십 KByte ~ 수백 KByte.


### Multi Level Cache Memory

<img src="image\20240226132515.png">

L1: 처리된 데이터를 저장하고, 수행해야 하는 작업에 대한 정보 저장
L2: CPU가 곧 사용할 명령과 데이터 저장
L3: 가장 크면서도 가장 느림. L3가 마지막 레벨의 캐시 메모리일 경우, L3를 LLC라 부르기도 함.

---

# 6. Garbage Collection?

: 프로그램 개발 시 유효하지 않은 메모리인 Garbage 발생. Heap 영역에서 동적 할당되었던 메모리 중 필요 없게 된 메모리 객체(Garbage)를 모아 주기적으로 제거하는 프로세스.

<img src="image\20240226135401.png">

- C / C++ 에서는 이런 가비지 콜렉션이 없어 프로그래머가 수동으로 할당 및 해제를 진행해야 했다.
- JAVA에서는 가비지 콜렉터가 메모리 관리를 대행해주기 때문에 JAVA가 한정된 메모리를 효율적으로 사용하게 해줌.
- 개발자 입장에서 메모리 관리, 메모리 누수 문제에 대해 관리하지 않고 오롯이 개발에만 집중할 수 있다.

## Garbage collection의 단점

- 메모리가 언제 해제되는지 파악하기 어려움.
- GC 동작시 다른 동작이 멈추므로 오버헤드가 발생하는 문제 발생.
- 다른 용어로 'Stop - The - World'라 부른다.
- 그러므로 만약 GC가 자주 실행된다면 소프트웨어 성능 하락의 문제가 되기도 한다.

### STW(Stop The World)

- GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상.
- GC 동작시 GC관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있음.
- 이를 최소화 시키는 것이 쟁점이라 할 수 있음.
 
<img src="image\20240226143401.png">


## GC의 작동 매커니즘

- 특정 개체가 garbage인지 유무를 판단하기 위해 도달성, 도달 능력(Reachability)이라는 개념을 적용함.
- 객체에 레퍼런스가 있다: Reachable
- 레퍼런스가 없다: Unrechable -> GC의 대상이 됨.

<img src="image\20240226150948.png">


### Mark and Sweep
: 가비지 콜렉션이 작동하는 아주 기초적인 청소 과정임.

<img src="image\20240226154104.png">

- 원리
	- 대상 객체를 식별(Mark)하고 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행하게 된다.
	- Mark: 각각의 Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
	- Sweep: 참조하고 있지 않은 객체를 Heap에서 제거한다.
	- Compact: Sweep 후 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 나눈다(GC 종류에 따라 안하는 경우도 있음.)

<img src="image\20240226160227.png">

---

# 7. Database index 추가시 장단점

## 인덱스(Index)란?

: 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료 구조.
- 해당 칼럼 데이터를 정렬한 후, 별도 메모리 공간에 데이터의 물리적 주소와 함께 저장됨.
 
<img src="image\20240227225857.png">

## 인덱스의 장단점

### 장점
- 테이블의 검색 속도 및 성능이 향상됨.
- 그에 따른 시스템의 전반적 부하 감소
- 인덱스에 의해서 데이터들이 정렬된 형태를 갖춤.
	- ORDER BY, MIN/MAX의 경우 수행이 빠르게 됨(이미 정렬되어 있어서.)

### 단점
- 인덱스를 관리하기 위한 추가적인 작업 필요
- 추가 저장 공간 필요
- 잘못 사용할 경우 검색 성능의 저하.
	- 데이터의 인덱스는 제거하는 것이 아니라 사용하지 않음 처리.

## 인덱스를 사용하기 좋은 경우
- 규모가 큰 테이블
- 삽입, 수정, 삭제 작업이 자주 발생하지 않는 경우
- WHERE, ORDER BY, JOIN 등이 자주 사용되는 칼럼
- 데이터의 중복도가 낮은 칼럼

---

# 8. 공유기(Router)의 원리

## Router

: 단일 IP에서 하위 클라이언트 PC가 유무선으로 하나의 인터넷 라인을 공유하여 동시에 인터넷 접속이 가능하게 함. WAN과 LAN 사이 중계 역할 수행. IP를 각각의 PC에 사설 IP를 분배하고, 공유기에 연결된 장치들이 통신을 시도하면 NAT 기술을 통해 외부망 서버에 메세지를 전달한다.

## 작동 원리

- NAT 기술 이용
	- NAT(Network Address Translation) -> IP 주소 = Network Address

- 두 종류의 연결 단자로 구성됨.
	- WAN(Wide Area Network)
	- LAN(Local Area Network )

- 클라이언트가 서버의 IP로 접속하게 될 때 동시에 클라이언트의 IP도 서버로 전달된다.

### WAN(Wide Area Network)

- 통신사에서 부여받은 케이블을 꽂는 단자.
- WAN단자에 케이블을 연결하면, 통신사로 부여받은 IP는 공유기가 차지하게 된다.
- 이렇게 부여받은 IP는 전 세계 어디서든 바로 접근 가능한 public IP address(공용 IP)라 부른다.

### LAN(Local Area Network)

- 하나의 인터넷 케이블을 공유할 기기들을 유선으로 연결할 수 있는 단자로, 유무선 차이없이 근본은 동일하다.
- LAN에 연결된 기기 또한 IP를 부여받으며, 공유기도 IP를 부여받는다.
- 결론적으로 공유기의 IP는 총 2가지이며, 각각 공용/사설 IP라 부른다.
- 사설 IP의 경우 외부에서 바로 접속할 수 없다.

---

# 08. HTTP/2

: 기존 HTTP 1.1의 버전 성능 향상에 초점을 맞춘 프로토콜

- 기존의 성능 저하 부분과 비효율적인 것들을 개선되어 탄생한 것임
- 기존 버전에서는 1번에 1개의 파일만 전송이 가능하였음.
	- 이 문제를 해결하기 위해서 여러파일을 한번에 병렬로 전송한다.
	- 그 결과 기존 버전에 비해서 속도가 15% ~ 50% 향상됨.

<img src="image\20240228151524.png">

---

# 09. 비대칭 암호

- 대칭키 암호화 하는 방식: 암복호화에 사용하는 키가 동일하다.
- 공개키 암호화 방식(비대칭시 암호화 방식):  암복호화에 사용하는 키가 서로 다르다.

## 대칭키 암호화

<img src="image\20240229113326.png">

- Session Key, Secret Key, 대칭키, 단용키 라고도 한다.
- 기밀성을 제공하나, 무결성/인증/부인방지 를 보장하지 않는다.
- 대표 알고리즘
	- SEED - 공인인증서 암호화 방식으로 유명
	- DES, 3DES, AES, ARIA, 최근 주목받고 있는 암호인 ChaCha20
#### 장점
- 암호화 방식의 속도가 빠름
- 대용량 데이터 암호화에 적합

#### 단점
- 키 교환의 문제
- 탈취 관리 문제(보안)
- 사람이 증가할수록 키 관리가 어려워짐
- 확장성이 떨어짐

## 비대칭키 암호

<img src="image\20240229114437.png">

#### 장점
- 키 분배 필요하지 않음.
- 기밀성 / 인증 / 부인방지 기능 제공
#### 단점
- 속도가 느림

#### 방식
- 암호 모드: 송신자 공개키로 암호화 -> 송신자 사설키로 복호화
	- 소량의 메세지 암호화 목적
	- 주로 키 교환의 용도로 사용
- 인증 모드: 송신자 사설키로 암호화 -> 송신자 공개키로 복호화
	- 메세지를 인증(부인 방지) 하는 것이 목적

- 대표 알고리즘
	- Diffie Hellman : 최초의 공개키 알고리즘, 위조에 취약
	- RSA : 대표적인 공개키 알고리즘
	- DSA : 전자서명 알고리즘의 표준
	- ECC : 짧은 키로 높은 암호 강도, 빠른 구현 가능 PDA, 스마트폰 등에 사용.

---
# 10. Node.js의 특징

## Node.js

- Node.js는 Chrome V8JavaScript 엔진으로 빌드된 **JavaScript 런타임**
- Node.js는 웹 서버의 개념이 아닌 javascript로 서버를 구축
- 서버에서 JavaScript가 작동되도록 해주는 **런타임 환경(플랫폼)**

## 특징

#### 장점

- 높은 처리 성능을 가지고 있다.
	- 단일 스레드(Single-Thread)의 논 블로킹(Non-blocking I/O) 이벤트 기반 비동기 방식으로 처리됨.
- 내장 HTTP 서버 라이브러리 포함
	- 웹 서버에서 아파치 등의 별도 소프트웨어 없이 동작 가능
	- 더 많은 통제 부여
- Javascript 언어로 Front-end, Back-end 개발환경 구성 가능
	- 높은 생산성 및 러닝커브의 감소
- 다양한 패키지 매니저를 기반으로 한 다양한 모듈을 제공, 필요 라이브러리에 대해 설치하고, 사용할 수 있기에 효율성이 좋다.

#### 단점

- 모든 방식이 비동기 기반 처리 방식이므로, 서버 로직이 복잡한 경우 콜백함수 늪에 빠질 수 있음.
- 단일 스레드 방식이므로 하나의 작업이 오래 걸리는 웹 서비스의 경우, 애플리케이션의 성능이 저하될 수 있다.
- 해당 코드가 수행이 되어야 코드에서 에러가 났는지 확인이 가능하며 에러 발생 시 프로세스가 내려갈 수 있다.
- 세선 공유시 redis와 같은 부가적인 인프라가 필요하다.
# 문제 설명

길이가 같은 배열 A, B 두개가 있습니다. 
각 배열은 자연수로 이루어져 있습니다.
배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 
이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 
이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. 
(단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)

```
예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면

A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. 
(누적된 값 : 0 + 5(1x5) = 5)

A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. 
(누적된 값 : 5 + 16(4x4) = 21)

A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. 
(누적된 값 : 21 + 8(2x4) = 29)

즉, 이 경우가 최소가 되므로 29를 return 합니다.
```
**배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.**

---

# 제한사항
- 배열 A, B의 크기 : 1,000 이하의 자연수
- 배열 A, B의 원소의 크기 : 1,000 이하의 자연수

# 입출력 예

|A|B|answer|
|--|--|--|
|[1, 4, 2]|[5, 4, 4]|29|
|[1,2]|[3,4]|10|

# 입출력 예 설명

## 입출력 예 #1
- 문제의 예시와 같습니다.

## 입출력 예 #2
- A에서 첫번째 숫자인 1, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. 

    (누적된 값 : 4) 
- 다음, A에서 두번째 숫자인 2, B에서 첫번째 숫자인 3을 뽑아 곱하여 더합니다.    
    (누적된 값 : 4 + 6 = 10)

- 이 경우가 최소이므로 10을 return 합니다.

---
# 문제 풀이

## 내 풀이
- 최솟값으로 만드는 방법
    - 최대값 * 최솟값 순으로 곱하면 됨

```python
def solution(A,B):
    answer = 0
    A = sorted(A)                   # 오름차순 -> 최솟값
    B = sorted(B, reverse=True)     # 내림차순 -> 최대값

    for i in range(len(A)):
        answer += (A[i] * B[i])

    return answer
```

## 다른 풀이

```python
def getMinSum(A, B):
    return sum([a * b for a, b in zip(sorted(A), sorted(B, reverse=True))])
```

- `zip()` 함수란?(GPT 참조)
```markdown
Python의 `zip()` 함수는 하나 이상의 이터러블(리스트, 튜플, 집합 등)을 받아서 각 이터러블에서 같은 인덱스의 요소들을 묶어 튜플로 반환해주는 함수입니다. 
이 함수는 여러 개의 이터러블을 동시에 반복할 때 유용하게 사용됩니다. 

예를 들어, 두 개의 리스트가 있을 때 각 리스트에서 같은 인덱스의 요소들을 묶어 새로운 리스트를 만들고 싶을 때 `zip()` 함수를 사용할 수 있습니다.

    ```python
    list1 = [1, 2, 3]
    list2 = ['a', 'b', 'c']

    zipped = zip(list1, list2)

    print(list(zipped))  # 출력: [(1, 'a'), (2, 'b'), (3, 'c')]
    ```

위의 예제에서 `zip(list1, list2)`는 `(1, 'a')`, `(2, 'b')`, `(3, 'c')`와 같이 두 리스트에서 같은 인덱스에 위치한 요소들을 묶어 튜플로 반환합니다.

`zip()` 함수는 이터러블의 길이가 서로 다를 경우 가장 짧은 이터러블의 길이에 맞추어 결과를 반환합니다. 
따라서 두 개 이상의 이터러블의 길이가 다른 경우에는 주의가 필요합니다.

    ```python
    list1 = [1, 2, 3]
    list2 = ['a', 'b']

    zipped = zip(list1, list2)

    print(list(zipped))  # 출력: [(1, 'a'), (2, 'b')]
    ```

위의 예제에서 `list2`의 길이가 `list1`보다 짧기 때문에 `zip()` 함수는 `list2`의 길이에 맞춰 결과를 반환합니다.

`zip()` 함수는 리스트뿐만 아니라 튜플, 집합, 문자열 등의 이터러블도 받을 수 있으며, 여러 개의 이터러블을 동시에 묶어줍니다.

```